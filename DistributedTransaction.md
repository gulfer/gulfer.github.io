# 分布式事务

最近在做代码评审的时候遇到这么一个问题：在某个声明式事务中使用了两个不同的数据源，而配置的事务管理器仍然是只支持单一数据源的DataSourceTransactionManager，这样会造成当某个操作失败抛出异常时将不会触发事务回滚。当时我提的建议是先评估一下功能场景，是否真的有必要将对两个不同数据源的操作放到同一事务中，如果一定要放在同一事务，至少要使用支持JTA的事务管理器。

我们需要简单了解下JTA事务和常见的JDBC事务的区别。JTA并不是这篇作业的主角，但了解JTA的机制将有助于理解后面的内容。我们知道事务的执行需要依赖资源管理器，在JDBC事务中就是DBMS，应用程序直接通过DataSource接口获取Connection，并通过Connection与资源管理器通信。而JTA事务则需要XA协议的支持，XA协议本质上是一种基于2PC的分布式事务协议，由支持分布式事务的事务管理器统一协调与各个支持XA协议的资源管理器的通信。我们在WebLogic上创建数据源时，会看到一页要求选择“是否支持全局事务”，如果选择支持，将创建XADataSource而非DataSource，对应的连接接口也变为XAConnection。而对于开发人员来说，JTA事务在实现上与普通JDBC事务并没有太大区别，需要关注的是事务管理器的具体实现，有一些开源的实现如Atomikos等，这里就不再单独举例了。

在各种微服务、分布式架构“大行其道”的现在，很多人会认为用了一些分布式软件、或做了数据拆分就是“分布式”了，而实际上真正的分布式系统在于各个分散资源的职责分配及功能协调，职责分配了，但是功能上没有协调和整合，和集群没啥分别。分布式事务的处理就是一种分布式环境下的功能协调，当一个场景下包含了分属不同资源管理器（不一定是DBMS）的操作，如何确保这些操作能协调一致的完成任务并不产生错乱，是非常重要的。

## 刚性事务与柔性事务

支付宝早在2008年就提出过柔性事务的概念，柔性事务是相对于刚性事务而言的，本地JDBC事务就是一种刚性事务。刚性事务要求严格遵守ACID，而分布式架构的应用，ACID特性是无法得到保障的，或者说保障的成本太高，因此需要换一种解决思路，就是柔性事务。柔性事务的理论基础是BASE理论，与ACID相对应，其中BA指的是Basic Availability，基本可用性，允许分区失败；S指的是Soft state，柔性状态，可以存在异步；E指得是Eventual consistency，最终一致性，不要求数据的实时一致。也就是说，BASE理论在确保可用性、性能的前提下，不要求强一致性。

## 柔性事务的几种处理思路

![柔性事务](https://github.com/gulfer/gulfer.github.io/blob/master/pic/soft-transaction.jpg)

柔性事务最开始是应对分布式的业务模块划分及数据划分，以及互联网应用面临的高并发场景设计的，所以说柔性事务也是分布式事务的另外一种形式。上图摘自支付宝的PPT，介绍了四种柔性事务的处理思路。需要说明的是，这些思路是一些解决分布式一致性的方法，每种思路适用于一些特定场景，所以这已经脱离了传统“事务”的概念，开发人员不再能像使用本地事务一样使用这些方法。而且是不是只有这几种处理方法，也未必一定。

* 2PC型

就是两阶段提交型。现在动辄提2PC，但实际上对应到不同的业务场景，每个阶段所执行操作的意义不同，不应混淆概念。比如执行某项业务需要先执行某些操作，用户确认后再执行其他操作，这种就不应该叫“两阶段提交”，因为既不是分布式的环境，也不是为了保证一致性。2PC分为准备和提交两个阶段，准备阶段和提交阶段，准备阶段期间各个分布式节点（资源管理器）检查是否可以执行某项操作，将事务操作信息记录在本地事务日志，并返回给发起节点或协调节点执行信息，事实上此时已经执行完成本地操作，资源已被占用，但并未提交而已，如果发生回滚，则根据本地事务日志执行回滚；到提交阶段，发起节点向各节点发出提交指令，才正式完成事务，并释放本地资源。

上文提到的JTA事务就属于2PC型，特点是整个事务过程是同步阻塞的，由于阻塞，当事务管理器发生故障时，所有参与事务处理的节点都会锁定，无法继续操作。为了解决同步阻塞的问题，一些分布式应用引入了3PC，将准备阶段再分为两步，不过这不是本文要讨论的要点，不做赘述。

我们知道2PC是同步阻塞的，也就知道2PC最大的问题就是执行效率比较低。但这仍然是一种分布式事务的解决思路，而实现上也相对简单。

* 补偿型

这里的补偿型方案主要是指TCC（Try-Confirm-Cancel）。其实TCC也是2PC的一种延伸，主要区别在于TCC不依赖于底层的事务管理器、资源管理器，而是完全由应用实现，灵活性比较好，想如何操作资源，是否锁定都可以自行决定。

支付宝的PPT里给出了完整的TCC解释，这里直接借用下：

**Try：尝试执行业务**
完成所有业务检查（一致性）
预留必须业务资源（准隔离性）

**Confirm：确认执行业务**
真正执行业务
不作任何业务检查
只使用Try阶段预留的业务资源
满足幂等性

**Cancel：取消执行业务**
释放Try阶段预留的业务资源
满足幂等性

方案示意图如下：

![TCC](https://github.com/gulfer/gulfer.github.io/blob/master/pic/tcc.png)

TCC事务是由主业务服务A发起的，各个从业务服务负责执行各自的本地事务，如一个转账操作，可能从服务B执行转账交易，从服务C执行限额处理。TCC的Try和Confirm可以对应2PC的两个阶段，而重点在于作为补偿的Cancel操作，在主业务服务A中的操作是可以先提交的，不再等待B和C执行完成，如果B发生回滚，则回调A和C的Cancel操作进行补偿。在阿里系的系统中有应用案例，不过对开发人员技术和业务理解能力要求比较高。实际上，个人认为在微服务架构中，TCC事务或者说补偿型的柔性事务，是一种比较合适的方案：在保证最终一致性的前提下，允许试错，提升整体事务执行效率。

github上可以看到一些TCC的实现框架，我们将在下节具体分析。

* 异步确保型

异步确保型的思路主要是同步转异步，而实现这个方案最主要的工具是消息队列，而且是支持事务消息的消息队列。我们看一下下面的图示：

![事务消息](https://github.com/gulfer/gulfer.github.io/blob/master/pic/msg.png)

这个方案的实现过程是这样的：

* 最大努力通知型



## 分布式事务框架

需

## 小结

其

参考书目：



